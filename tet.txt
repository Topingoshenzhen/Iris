1、
请简述比特币系统中的pow算法，并绘图描述其工作流程。

PoW，全称Proof of Work，即工作量证明，又称挖矿。
1、生成挖矿交易，并与其它所有准备打包进区块的交易组成交易列表，生成Merkle根哈希值。
2、将Merkle根哈希值，与区块头其它字段组成区块头，80字节长度的区块头作为Pow算法的输入字符串。
3、不断变更区块头中的随机数Nonce，对变更后的区块头做双重SHA256哈希运算，使得结果哈希值满足给定数量前多少位为0的过程，
4、其中前多少位为0的具体个数，取决于挖矿难度，前导0的个数越多，挖矿难度越大。
   (这种说法也成立：与当前难度的目标值做比对，如果小于目标难度，即Pow完成。)






PoW，全称Proof of Work，即工作量证明，又称挖矿。大部分公有链或虚拟货币，如比特币、以太坊，均基于PoW算法，来实现其共识机制。即根据挖矿贡献的有效工作，来决定货币的分配。80字节长度的区块头，即为比特币Pow算法的输入字符串。交易列表附加在区块头之后，其中第一笔交易为矿工获得奖励和手续费的特殊交易。

比特币Pow算法原理：
Pow的过程，即为不断调整Nonce值，对区块头做双重SHA256哈希运算，使得结果哈希值满足给定数量前多少位为0的过程。
其中前多少位为0的具体个数，取决于挖矿难度，前导0的个数越多，挖矿难度越大。

1、生成铸币交易，并与其它所有准备打包进区块的交易组成交易列表，生成Merkle根哈希值。
2、将Merkle根哈希值，与区块头其它字段组成区块头，80字节长度的区块头作为Pow算法的输入。
3、不断变更区块头中的随机数Nonce，对变更后的区块头做双重SHA256哈希运算，与当前难度的目标值做比对，如果小于目标难度，即Pow完成。

Pow完成的区块向全网广播，其他节点将验证其是否符合规则，如果验证有效，其他节点将接收此区块，并附加在已有区块链之后。之后将进入下一轮挖矿。



比特币挖矿难度计算
 
每创建2016个块后将计算新的难度，此后的2016个块使用新的难度。计算步骤如下：
 
　　1、找到前2016个块的第一个块，计算生成这2016个块花费的时间。
       即最后一个块的时间与第一个块的时间差。时间差不小于3.5天，不大于56天。
　　2、计算前2016个块的难度总和，即单个块的难度x总时间。
　　3、计算新的难度，即2016个块的难度总和/14天的秒数，得到每秒的难度值。
　　4、要求新的难度，难度不低于参数定义的最小难度。


以太坊区块
 
　　以太坊区块由Header和Body两部分组成。
 
　　其中Header部分成员如下：
　　ParentHash，父区块哈希
　　UncleHash，叔区块哈希，具体为Body中Uncles数组的RLP哈希值。RLP哈希，即某类型对象RLP编码后做SHA3哈希运算。
　　Coinbase，矿工地址。
　　Root，StateDB中state Trie根节点RLP哈希值。
　　TxHash，Block中tx Trie根节点RLP哈希值。
　　ReceiptHash，Block中Receipt Trie根节点的RLP哈希值。
　　Difficulty，区块难度，即当前挖矿难度。
　　Number，区块序号，即父区块Number+1。
　　GasLimit，区块内所有Gas消耗的理论上限，创建时指定，由父区块GasUsed和GasLimit计算得出。
　　GasUsed，区块内所有Transaction执行时消耗的Gas总和。
　　Time，当前时间戳。
　　Nonce，随机数Nonce值。
 
　　有关叔区块：
　　叔区块，即孤立的块。以太坊成块速度较快，导致产生孤块。
　　以太坊会给发现孤块的矿工以回报，激励矿工在新块中引用孤块，引用孤块使主链更重。在以太坊中，主链是指最重的链。
 
　　有关state Trie、tx Trie和Receipt Trie：
　　state Trie，所有账户对象可以逐个插入一个Merkle-PatricaTrie(MPT)结构中，形成state Trie。
　　tx Trie：Block中Transactions中所有tx对象，逐个插入MPT结构中，形成tx Trie。
　　Receipt Trie：Block中所有Transaction执行后生成Receipt数组，所有Receipt逐个插入MPT结构中，形成Receipt Trie。
 
　　Body成员如下：
　　Transactions，交易列表。
　　Uncles，引用的叔区块列表。


2、
请简述Bolt数据库在区块链数据存储中的作用，它是如何存储区块数据的。


Bolt数据库实现数据持久化。区块链是由创世区块引导的，按照以下步骤添加创世区块以及普通区块：


1.创建DB文件并打开

2.创建存储区块信息的桶

3.把创世区块的信息进行序列化，并存储DB中
4.把创世区块添加到链中。
5.Bolt是Key/Value（键/值）存储,key, value类型全部为[]byte。普通区块直接添加到链中，key可以用区块hash












3、
请简述utxo是什么，并解释TXInput，和TXOutput是什么，并说明TXInput和TXOutput中的字段都有什么

UTXO：unspent transaction output，是比特币交易中最小的支付单元，不可分割，被所有者锁住或记录于区块链中的并被整个网络识别成货币单位的一定量的比特币货币，
即只记录未花费的比特币输出。每一个UTXO必须一次性消耗完，然后生成新的UTXO。UTXO被每一个全节点比特币客户端在一个储存于内存中的数据库所追踪，该数据库也被称为
“UTXO集”或者“UTXO池”。


比特币的每一笔交易是由输入TXInput与输出TXOutput组成的，而不是账户地址。


TXInput：
字节长度	字段			说明
32		交易哈希值		指向要被花费的UTXO所在的交易的哈希，如果是coinbase，固定为全0
4		输出索引		被花费的UTXO的索引号，第一个是0，如果是coinbase，固定为全1
1-9		解锁脚本大小		用字节表示的后面的解锁脚本长度
不定		解锁脚本		满足UTXO解锁脚本条件的脚本，锁定脚本的前两个数字转换成十进制数，表示将该十进制数个字节压入堆栈。如果是coinbase，数据任意填充。
4		序列号			固定值0xffffffff





TXOutput：

字节长度	字段			说明
8		总量			8个字节表示比特币的数量，用聪作为单位，1BTC = 一亿 satoshi(聪：比特币区块链上最小的单位)
1-9		锁定脚本大小		用字节表示的后面的锁定脚本长度
不定		锁定脚本		一个定义了花费输出所需条件的脚本，锁定脚本的前两个数字转换成十进制数，表示将该十进制数个字节压入堆栈









UTXO：unspent transaction output，是比特币交易中最小的支付单元，不可分割，每一个UTXO必须一次性消耗完，然后生成新的UTXO，存放在比特币网络的UTXO池中。


UTXO是不能再分割、被所有者锁住或记录于区块链中的并被整个网络识别成货币单位的一定量的比特币货币。


比特币网络监测着以百万为单位的所有可用的（未花费的）UTXO。当一个用户接收比特币时，金额被当作UTXO记录到区块链里。这样，一个用户的比特币会被当作UTXO分散到数百个交易和数百个区块中。


实际上，并不存在储存比特币地址或账户余额的地点，只有被所有者锁住的、分散的UTXO。


“一个用户的比特币余额”，这个概念是一个通过比特币钱包应用创建的派生之物。比特币钱包通过扫描区块链并聚合所有属于该用户的UTXO来计算该用户的余额。


UTXO被每一个全节点比特币客户端在一个储存于内存中的数据库所追踪，该数据库也被称为“UTXO集”或者“UTXO池”。新的交易从UTXO集中消耗（支付）一个或多个输出。













4、
请简述锁定脚本和解锁脚本在比特币转账过程中的作用


解锁脚本：是由签名与公钥组成，是检验input是否可以使用由某个地址锁定的utxo。外部提供锁定信息，我去检查一下能否解开它
锁定脚本；
	  保证必须拥有私钥的用户才能对某一笔交易进行解锁
锁定脚本：是用于指定比特币新的主人，在创建output的时候创建，对于这个output来说，他应该是一直在等待一个签名的到来，来检查这个签名能否解开自己锁定的比特币。










5、
请简述课程比特币项目中一个区块都包含什么字段，每个字段分别起到什么作用

区块整体结构包括以下字段：

	区块大小，4个字节，用字节表示的该字段之后的区块大小

	区块头， 80个字节，结构:Block

	交易计数器， 1 - 9个字节，该区块包含的全部交易数量

	交易列表，长度为不定，记录在区块里面的交易信息


//区块头的结构体：

type Block struct {

	//1. 版本号，也就是支持的比特币系统的版本
	Version uint64  //无符号，整形，长度为64位 % 8 = 8 字节
	//2. 前区块哈希，比特币的区块哈希值其实就是区块头的双哈希的大端表示，然后转换为大数与难度值进行比较，存储的             区块链原始数据其实是小端格式哈希值交易与区块的哈希值是字节反转类型，类似于两个反转的三角形
	PrevHash []byte
	//3. Merkel根（梅克尔根，这就是一个哈希值，交易列表生成的梅克尔树根哈希）
	MerkelRoot []byte
	//4. 时间戳，该区块产生的近似时间，精确到秒的UNIX时间戳，用的是Linux时间表示方法，区块根据时间戳进行排序
	TimeStamp uint64
	//5. 难度值，挖矿难度值，值越大，挖矿越难
	Difficulty uint64
	//6. 随机数，也就是挖矿使用的随机数，每次加1
	Nonce uint64
}


//区块体：记录在区块里面的交易信息
Data []byte  




交易信息前面几个字节表示的是该区块包含的交易数量，coinbase交易也计入在内。交易数量类型采用的是一种压缩尺寸的变长整型。可以看出第一个字节是0x02，这就说明本区块只有2个交易：一个coinbase交易和一个普通交易。每个区块第一个交易规定为coinbase交易。


coinbase结构为：每个区块的第一个交易叫做coinbase交易
结构：
	交易版本号，	4个字节，    	明确这笔交易参照的规则
	输入计数器，	  1-9个字节，	包含交易输入数量，coinbase只有一个输入
	交易输入，  	不定，       	交易输入结构
	输出计数器， 	  1-9个字节，	包含交易输出数量，一个or多个
	交易输出，  	不定，       	一个or多个交易输出
	锁定时间，  	4个字节，    	一个区块号 or UNIX时间戳，锁定时间为0，表示立即执行

coinbase交易的输入格式经过数次改变，在高度227836之前遵从的区块版本号为1。因为本文分析的区块实例高度为170，则coinbase交易遵从版本1的规定。之后的区块版本中规定coinbase数据中需要添加区块高度值，版本2、3、4更详细的说明可以查看比特币官网的开发文档，在此不再赘述。


交易输入结构为：

字节长度	字段			说明
32		交易哈希值		32个字节表示引用的UTXO交易哈希值，固定为全0
4		输出索引		其中4个字节表示引用的UTXO所对应的输出索引，固定为全1
1-9		Coinbase脚本长度	coinbase的脚本字节长度
不定		coinbase脚本		coinbase脚本数据，跟普通交易的解锁脚本不同，因为是创币交易，则coinbase的脚本不需要对其它UTXO进行解锁，故可以填充任意数据
4		序列号			固定值0xFFFFFFFF



交易输出结构为:

字节长度	字段			说明
8		总量			8个字节表示挖出新比特币的数量，用聪作为单位，1BTC = 一亿 satoshi(聪：比特币区块链上最小的单位)
1-9		锁定脚本大小		表示锁定脚本的字节长度
不定		锁定脚本		一个定义了支付输出所需条件的脚本，锁定脚本的前两个数字转换成十进制数，表示将该十进制数个字节压入堆栈


coinbase hash struct:
{
  "block_hash": "00000000d1145790a8694403d4063f323d499e655c83426834d4ce2f8dd4a2ee",
  "block_height": 170,
  "block_index": 0,
  "hash": "b1fea52486ce0c62bb442b530a3f0132b826c74e473d1f2c220bfa78111c5082",
  "addresses": [
    "1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc"
  ],
  "total": 5000000000,
  "fees": 0,
  "size": 134,
  "preference": "low",
  "confirmed": "2014-11-16T18:53:46.237Z",
  "received": "2014-11-16T18:53:46.237Z",
  "ver": 1,
  "double_spend": false,
  "vin_sz": 1,
  "vout_sz": 1,
  "confirmations": 586020,
  "confidence": 1,
  "inputs": [
    {
      "output_index": -1,
      "script": "04ffff001d0102",
      "sequence": 4294967295,
      "script_type": "empty",
      "age": 170
    }
  ],
  "outputs": [
    {
      "value": 5000000000,
      "script": "4104d46c4968bde02899d2aa0963367c7a6ce34eec332b32e42e5f3407e052d64ac625da6f0718e7b302140434bd725706957c092db53805b821a85b23a7ac61725bac",
      "addresses": [
        "1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc"
      ],
      "script_type": "pay-to-pubkey"
    }
  ]
}




普通交易结构为：

	交易版本号，	4个字节，    	明确这笔交易参照的规则
	输入计数器， 	 1-9个字节，	包含交易输入数量，一个or多个
	交易输入，  	不定，       	一个or多个交易输入
	输出计数器， 	 1-9个字节，	包含交易输出数量，一个or多个
	交易输出，  	不定，       	一个or多个交易输出
	锁定时间，  	4个字节，    	一个区块号 or UNIX时间戳，锁定时间为0，表示立即执行




普通交易输入结构为：

字节长度	字段			说明
32		交易哈希值		指向要被花费的UTXO所在的交易的哈希
4		输出索引		被花费的UTXO的索引号，第一个是0
1-9		解锁脚本大小		用字节表示的后面的解锁脚本长度
不定		解锁脚本		满足UTXO解锁脚本条件的脚本，锁定脚本的前两个数字转换成十进制数，表示将该十进					制数个字节压入堆栈
4		序列号			固定值0xffffffff




普通交易输出结构为：

字节长度	字段			说明
8		总量			8个字节表示转账比特币的数量，用聪作为单位，1BTC = 一亿 satoshi(聪：比特币区块链上最小的单位)
1-9		锁定脚本大小		用字节表示的后面的锁定脚本长度
不定		锁定脚本		一个定义了支付输出所需条件的脚本，锁定脚本的前两个数字转换成十进制数，表示将该十进制数个字节压入堆栈
	



{
  "block_hash": "00000000d1145790a8694403d4063f323d499e655c83426834d4ce2f8dd4a2ee",
  "block_height": 170,
  "block_index": 1,
  "hash": "f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16",
  "addresses": [
    "12cbQLTFMXRnSzktFkuoG3eHoMeFtpTu3S",
    "1Q2TWHE3GMdB6BZKafqwxXtWAWgFt5Jvm3"
  ],
  "total": 5000000000,
  "fees": 0,
  "size": 275,
  "preference": "low",
  "confirmed": "2009-01-12T03:30:25Z",
  "received": "2009-01-12T03:30:25Z",
  "ver": 1,
  "double_spend": false,
  "vin_sz": 1,
  "vout_sz": 2,
  "confirmations": 586024,
  "confidence": 1,
  "inputs": [
    {
      "prev_hash": "0437cd7f8525ceed2324359c2d0ba26006d92d856a9c20fa0241106ee5a597c9",
      "output_index": 0,
      "script": "47304402204e45e16932b8af514961a1d3a1a25fdf3f4f7732e9d624c6c61548ab5fb8cd410220181522ec8eca07de4860a4acdd12909d831cc56cbbac4622082221a8768d1d0901",
      "output_value": 5000000000,
      "sequence": 4294967295,
      "addresses": [
        "12cbQLTFMXRnSzktFkuoG3eHoMeFtpTu3S"
      ],
      "script_type": "pay-to-pubkey",
      "age": 9
    }
  ],
  "outputs": [
    {
      "value": 1000000000,
      "script": "4104ae1a62fe09c5f51b13905f07f06b99a2f7159b2225f374cd378d71302fa28414e7aab37397f554a7df5f142c21c1b7303b8a0626f1baded5c72a704f7e6cd84cac",
      "spent_by": "ea44e97271691990157559d0bdd9959e02790c34db6c006d779e82fa5aee708e",
      "addresses": [
        "1Q2TWHE3GMdB6BZKafqwxXtWAWgFt5Jvm3"
      ],
      "script_type": "pay-to-pubkey"
    },
    {
      "value": 4000000000,
      "script": "410411db93e1dcdb8a016b49840f8c53bc1eb68a382e97b1482ecad7b148a6909a5cb2e0eaddfb84ccf9744464f82e160bfa9b8b64f9d4c03f999b8643f656b412a3ac",
      "spent_by": "a16f3ce4dd5deb92d98ef5cf8afeaf0775ebca408f708b2146c4fb42b41e14be",
      "addresses": [
        "12cbQLTFMXRnSzktFkuoG3eHoMeFtpTu3S"
      ],
      "script_type": "pay-to-pubkey"
    }
  ]
}




























在比特币系统中并没有账户的概念，有的是遍布全网区块链的UTXO。所谓UTXO是指关联比特币地址的比特币金额的集合，是一个包含数据和可执行代码的数据结构。一个UTXO的基本单位是“聪”，“聪”是比特币的最小计量单位，一个比特币等于10^8聪。一个UTXO一旦被创建则不可分割，只能当做交易的输入被花费掉，花费后产生新的UTXO，花费后产生新的UTXO，这样周而复始地实现货币的价值转移。因此我们使用的比特币钱包看到的账户余额实际上时UTXO聚合计算的产物。

比特币的交易由交易输入和交易输出组成，UTXO是交易输入和输出的一部分，所以说UTXO是交易最基本的组成单元。

一个交易输入指向特定的UTXO，并且包含签名脚本，这个签名脚本用来满足UTXO的花费条件，为真则宣布自己对这笔资金拥有所有权。实际上节点在构造交易时会根据一定的算法选择一定数量的UTXO，同时生成相应的脚本签名作为输入的一部分加入到交易中。

每一个交易输出都伴随着资金的转移，交易输出包含一定数量的比特币和锁定脚本。锁定脚本作为资产指向一个比特币地址而设置的花费条件，只有满足这个花费条件的人才可以花费这笔资金。

总得来说，交易的输入和输出总是在大都数交易中都会同时出现，这样就实现比特币资金的价值转移，当然还有一种交易模型有些特殊，它只有输出，这就是比特币区块中第一笔交易称为coinbase交易，也称这为创币交易，它没有输入，是系统用于对矿工工作量证明的奖励，稳定增加相应的货币供应。

UTXO作为比特币独创的价值转移基本单元。比特币网络安全运行多年证明UTXO模型经受住考验，是与账户差异化的一种金融交易模式，对整个金融行业具有重大的积极影响！UTXO和Account各有各的优劣，在区块链项目和落地场景中选择合适的模型是极为关键的。目前比特币采用UTXO，以太坊选用的是Account，其它绝大多数区块链项目都基于这两种模型或变种。



在 Bitcoin 以及其他使用 UTXO 模型的加密货币中，某一个『账户』中的余额并不是由一个数字表示的，而是由当前区块链网络中所有跟当前『账户』有关的 UTXO 组成的。UTXO 中包含了很多信息，例如：包含当前 UTXO 属于的交易索引 tx_index、交易接收方的地址 addr、交易的数额 value。


在比特币中，一笔交易“在黑盒子里”实际运作的方式是：花费一种东西的集合，这种东西被称为 “未被花费的交易输出”（即 “UTXO” ），这些输出由一个或多个之前的交易所创造，并在其后制造出一笔或多笔新的 UTXO ，可以在未来的交易中花费。每一笔 UTXO 可以被理解为一个 “coin（币）”：它有面额、有一个所有者。而且，一笔交易若要有效，必须满足的两个规则是：1）该交易必须包含一个有效的签名，来自它所花费的 UTXO 的拥有者；2）被花费的 UTXO 的总面额必须等于或者大于该交易产生的 UTXO 的总面额。一个用户的余额因此并不是作为一个数字储存起来的；而是用他占有的 UTXO 的总和计算出来的。

如果一个用户想要发送一笔交易，发送 X 个币到一个特定的地址，有时候，他们拥有的 UTXO 的一些子集组合起来面值恰好是 X，在这种情况下，他们可以创造一个交易：花费他们的 UTXO 并创造出一笔新的、价值 X 的 UTXO ，由目标地址占有。当这种完美的配对不可能的时候，用户就必须打包其和值 大于 X 的 UTXO 输入集合，并添加一笔拥有第二个目标地址的 UTXO ，称为“变更输出”，分配剩下的币到一个由他们自己控制的地址。


每一个未被使用的 output 就是一个 UTXO（Unspent Transaction Output），我们可以通过其中的 addresses 字段找到持有当前输出的地址。

UTXO 模型通过链式的方式组织所有交易的输入和输出，每一个交易的输出最终都能追寻到一个 Coinbase，也就是当前 Bitcoin 被挖出时的区块的第一笔交易。

transactions-in-utxo-mode

由于在 UTXO 中没有账户的概念，所以并行地处理交易不会出现任何问题，同时不可变的账本能够让我们在 Bitcoin 节点快速更新时，也能分析某一时刻整个网络中数据的快照。

虽然 UTXO 模型的不可变账本条目带来一些好处，但是当我们需要计算某个地址中的余额时，需要遍历整个网络中的全部相关区块，同时，并行的处理交易虽然可行，不过并行的创建交易却会出现很多问题，例如多笔交易使用了同一个 UTXO，导致双花，最终只有一笔交易能够被网络确认。只确认一笔导致什么结果？

UTXO 模型确实能够解决区块链世界中的各种问题，它的核心思想就是保证已经写入的数据不可变，链式的 UTXO 就是基于这一核心思想的，通过哈希指针连接不同交易的输入和输出，保证所有交易的合法性。



无论是 UTXO 模型还是账户余额模型，都能够很好地解决区块链世界中的『安全』问题，保证交易的合法，从原理上杜绝一些可能的攻击行为，实现原理的不同其实也只是由于出发点不同，在设计时权衡了利弊；UTXO 模型相比于账户余额模型有以下的两个优点：

如果用户启用了新的地址用于转账和交易，新地址与原地址之间的关系很难被追踪，更好地保证用户的隐私；
UTXO 模型理论上来说可以并行地利用不同的 UTXO 签发多笔交易，并广播到网络中；
而账户余额模型也有它的优点：

非常容易理解和编码实现；
每一笔交易都只需要有一个签名，交易的输入和输出都是地址，能够节省存储空间；
由于在区块链层级没有『币的来源』这一概念，很难实现对来源的追踪和回溯；
因为创建交易时不需要对过去的 UTXO 进行签名，可以从任何一个时间点开始同步区块的状态，利于编写轻量级客户端；

在比特币交易系统中，没有账户iD和账户密码一说，也没有账户余额计算一说。但是 有公钥（钱包地址）和秘钥，可以浅显的类比理解为：公钥就是账户ID，私钥就是账户密码。在比特币交易系统中，知道对方公钥，就可以给对方转账进行交易。拥有了私钥，就代表着拥有了该地址下所有UTXO的使用权和控制权。

总而言之，软件开发到最后就是进行权衡的过程，选择一些优势必然会在另外一些领域上处于劣势，如何在不同的需求进行权衡是开发区块链应用以及所有应用都需要考虑的事情。










比特币：

比特币不是一种货币，而是一个分布式账本，or 各种技术组在一起的总称


比特币系统分为：

分布式数据存储

点对点传输，通信

共识机制POW

加密算法



账本一致性，比特币系统规则 --》 最长链为可信任的链条。如果有分叉的话，这个规则适用与区分正确交易 or 让攻击者褚篡改区块链称为impossibile，因为如果有篡改，造成了分叉，那么该攻击者必须保证自己分叉的整条连算例时时超过公链，一旦落后了，成本越来越大。


比特币中的矿工：创造区块，使链增长，通过工作量证明方式争夺记账权


POW：
系统抛出一个计算量很大的数学题  --》  各个节点开始竞争挖矿，比拼计算机算力  --》  胜出的节点取得记账权  --》  将交易信息打造成新的区块并给区块标号

--》  将新的区块信息广播出去


这里面的标号是区块的高度，从0开始，代表区块在区块链的位置，高度？


比特币解决双重支付(双花)问题
1，比特币系统规则：最长链为可信任的链
2，采用工作量证明(POW)获取记账权



比特币的分叉：通常是不同的旷工，使用了不同版本的比特币系统进行挖矿，导致链条分叉，这是旷工在系统协议层面上产生了分歧。


分叉的类型：

硬分叉：系统更新产生硬分叉，并且不可以合并。例如：比特币扩容

最初的区块只有1M，后来区块大小调整为8M，只有节点更新了比特币系统，才可以接收8M新区块。新系统可以兼容旧系统区块。旧系统无法兼容新系统区块。
参考windows系统兼容。例如；新区块所在链上可以兼容旧区块，如果旧系统挖出了一条链的旧区块，这条旧区块链就在新区块所在链上形成了分叉。如果旧分叉一直没有更新系统，那么导致分叉无法合并一直存在，最终，旧区块称为比特币，新区块所在链为比特币现金


软分叉：软分叉可以合并。例如篡改数据


以上这些理解为比特币1.0技术


接下里是比特币2.0技术

因为比特币1.0有如下问题：

1，交易速度慢，每10分钟出一个块，每秒大概支持全球7比交易，每比交易大概250个字节容量

2，pow特别消耗资源，例如电量，所以现在都是各个大集团或者各大集团联合起来在挖矿，个人电脑，矿机挖矿已经过时了

3，仅仅完成了货币的区中心化


以太坊：是一个运行在计算机网络的软件，确保了数据以及智能合约的小程序可以在没有中心协调者的情况下，都被网络中的计算机复制以及处理。
其愿景是创建一个无法停止，抗屏蔽(审查)以及自我维持的去中心化世界计算机。


1，交易速度快，出快速度15秒

2，POW+POS算法，逐步向POS算法过度。POS(权益证明)

3，引入智能合约，例如承诺书，如果违反直接了扣违约金等。这样不受人为因素影响，避免国与国差异。



以太坊平台专业词汇：

以太坊用户：记录数据(矿工)，发布智能合约(撰写合同)，参与智能合约(参与合同)

账户地址：用户在以太坊平台付款或者收款的地址，类似与银行号

以太币：

转账：收款人地址，金额，附言

手续费(汽油费gas fee)：Gas Price(汽油价)，Gas Limit(油数量)，计算公式：fee = Gas Price * Gas Limit，网络拥堵手续费高，网络顺畅手续费低
并且手续费给多了可以退回，给少了导致写入数据失败并且手续费不退回


智能合约：跑在以太坊系统中的代码合同，其实质是一段代码。目前已经存在180多万个智能合约，它们类似与公示出来的法律合同，违反的人将收到处罚。规则明确不受主观因素影响。


Ghost协议：以太坊出块太快产生的区块分叉问题


POS算法：又称为虚拟挖矿。



























列举所有地址...
地址：1CZRL69YFm4y5YHdcQZxo19mV6hFZU8rxq
地址：1MVET32q6mkQ3hqFq7cnb7yPfEbKoMS2ZE
地址：14kuGBbRpkqgbJR8XggTFSSxkJ9srM2Mta
地址：19mLTxsXQEdhJjFNGQ2K68hF7YL5u4HGSu
地址：14PxkwD8cTpzNAT1PYXRwK4qRNbkBVtgFP
地址：1MfLyebvJWS9esDtZbkEmFw86R8M9LqHvX
地址：14o5rZTP6gLNDSQzs63ArFS3rUaU7Wdqb9
地址：1CJ3fxMWnMi6qwb6NjMokN6sX25L2G3EgP








































